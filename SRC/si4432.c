#include  "si4432.h"

#define BW_9600

void si4432_init(void) {
    rf_sdn_high();
    delay(10);
    rf_sdn_low();
    while(spi_rw_byte(0,0) != 0x08);

    spi_rw_byte(0x05|0x80, 0x00);
    spi_rw_byte(0x06|0x80, 0x00);
    spi_rw_byte(0x03,0x00);	    // 清RF模块中断
    spi_rw_byte(0x04,0x00);

    spi_rw_byte(0x05|0x80, 0x00);   //  关闭不需要的中断
    spi_rw_byte(0x06|0x80, 0x00);

    spi_rw_byte(0x09|0x80, 0x7f);   // 负载电容= 12P
    spi_rw_byte(0x0a|0x80, 0x05);   // 关闭低频输出
    spi_rw_byte(0x0b|0x80, 0xea);   // GPIO 0 当做普通输出口
    spi_rw_byte(0x0c|0x80, 0xea);   // GPIO 1 当做普通输出口
    spi_rw_byte(0x0d|0x80, 0xf4);   // GPIO 2

#ifdef  BW_100000
    spi_rw_byte(0x1c|0x80, 0x88);   // 下面的设置根据Silabs 的Excel
    spi_rw_byte(0x1d|0x80, 0x44);   // 使能 afc
    spi_rw_byte(0x1e|0x80, 0x02);
    spi_rw_byte(0x1f|0x80, 0x03);

    spi_rw_byte(0x20|0x80, 0x3c);
    spi_rw_byte(0x21|0x80, 0x01); //
    spi_rw_byte(0x22|0x80, 0x11); //
    spi_rw_byte(0x23|0x80, 0x11); //
    spi_rw_byte(0x24|0x80, 0x07); //
    spi_rw_byte(0x25|0x80, 0xFF); //

    spi_rw_byte(0x2a|0x80, 0x50);
#endif

#ifdef  BW_50000
    spi_rw_byte(0x1c|0x80, 0x9A);   // 下面的设置根据Silabs 的Excel
    spi_rw_byte(0x1d|0x80, 0x44);   // 使能 afc
    spi_rw_byte(0x1e|0x80, 0x0A);
    spi_rw_byte(0x1f|0x80, 0x03);

    spi_rw_byte(0x20|0x80, 0x3c);
    spi_rw_byte(0x21|0x80, 0x01); //
    spi_rw_byte(0x22|0x80, 0x11); //
    spi_rw_byte(0x23|0x80, 0x11); //
    spi_rw_byte(0x24|0x80, 0x07); //
    spi_rw_byte(0x25|0x80, 0xFF); //

    spi_rw_byte(0x2a|0x80, 0x48);
#endif

#ifdef  BW_9600
    spi_rw_byte(0x1c|0x80, 0xac);   // 下面的设置根据Silabs 的Excel
    spi_rw_byte(0x1d|0x80, 0x44);   // 使能 afc
    spi_rw_byte(0x1e|0x80, 0x0a);
    spi_rw_byte(0x1f|0x80, 0x03);

    spi_rw_byte(0x20|0x80, 0x9c);
    spi_rw_byte(0x21|0x80, 0x00); //
    spi_rw_byte(0x22|0x80, 0x68); //
    spi_rw_byte(0x23|0x80, 0xdc); //
    spi_rw_byte(0x24|0x80, 0x00); //
    spi_rw_byte(0x25|0x80, 0xa3); //

    spi_rw_byte(0x2a|0x80, 0x28);
#endif

    spi_rw_byte(0x30|0x80, 0x8c);  // 使能PH+ FIFO模式，高位在前面，使能CRC校验
    spi_rw_byte(0x32|0x80, 0x08);  // byte0, 1,2,3 作为头码
    spi_rw_byte(0x33|0x80, 0x12);  //  byte 0,1,2,3 是头码，同步字3,2 是同步字
    spi_rw_byte(0x34|0x80, 0X04);  // 发射8个Nibble的Preamble
    spi_rw_byte(0x35|0x80, 0x22);  // 需要检测4个nibble的Preamble
    spi_rw_byte(0x36|0x80, 0x2d);  // 同步字为 0x2dd4
    spi_rw_byte(0x37|0x80, 0xd4);
    spi_rw_byte(0x38|0x80, 0x00);
    spi_rw_byte(0x39|0x80, 0x00);
//    spi_rw_byte(0x3a|0x80, 's');   // 发射的头码为： “swwx"
//    spi_rw_byte(0x3b|0x80, 'w');
//    spi_rw_byte(0x3c|0x80, 'w');
//    spi_rw_byte(0x3d|0x80, 'x');
//    spi_rw_byte(0x3e|0x80, 16);   // 总共发射10个字节的数据
//    spi_rw_byte(0x3f|0x80, 's');  // 需要校验的头码为：”swwx"
//    spi_rw_byte(0x40|0x80, 'w');
//    spi_rw_byte(0x41|0x80, 'w');
//    spi_rw_byte(0x42|0x80, 'x');
    spi_rw_byte(0x43|0x80, 0xFF);  //
    spi_rw_byte(0x44|0x80, 0x00);  //
    spi_rw_byte(0x45|0x80, 0x00);  //
    spi_rw_byte(0x46|0x80, 0x00);  //

    spi_rw_byte(0x6d|0x80, 0x0F);  // 设置为最大功率发射

#ifdef  BW_100000
    spi_rw_byte(0x69|0x80, 0x60);
    spi_rw_byte(0x6e|0x80, 0x19);
    spi_rw_byte(0x6f|0x80, 0x9a);
    spi_rw_byte(0x70|0x80, 0x0e);
    spi_rw_byte(0x71|0x80, 0x23);   // 发射不需要 CLK，FiFo ， FSK模式
    spi_rw_byte(0x72|0x80, 0x50);   // 频偏为 50KHz
#endif

#ifdef  BW_50000
    spi_rw_byte(0x69|0x80, 0x60);
    spi_rw_byte(0x6e|0x80, 0x0C);
    spi_rw_byte(0x6f|0x80, 0xCD);
    spi_rw_byte(0x70|0x80, 0x0e);
    spi_rw_byte(0x71|0x80, 0x23);   // 发射不需要 CLK，FiFo ， FSK模式
    spi_rw_byte(0x72|0x80, 0x50);   // 频偏为 50KHz
#endif

#ifdef  BW_9600
    spi_rw_byte(0x69|0x80, 0x60);
    spi_rw_byte(0x6e|0x80, 0x4e);
    spi_rw_byte(0x6f|0x80, 0xa5);
    spi_rw_byte(0x70|0x80, 0x2e);
    spi_rw_byte(0x71|0x80, 0x23);   // 发射不需要 CLK，FiFo ， FSK模式
    spi_rw_byte(0x72|0x80, 0x50);   // 频偏为 50KHz
#endif

    spi_rw_byte(0x73|0x80, 0x00);   // 没有频率偏差
    spi_rw_byte(0x74|0x80, 0x00);   // 没有频率偏差
    spi_rw_byte(0x75|0x80, 0x53);   // 频率设置 433.5
    spi_rw_byte(0x76|0x80, 0x57);   //
    spi_rw_byte(0x77|0x80, 0x80);

    spi_rw_byte(0x7a|0x80, 50);  // step 500KHz
		
		spi_rw_byte(0x7D|0x80, 0x1F);
		spi_rw_byte(0x7E|0x80, 0x1F);		
}

void set_channel(uint8_t ch) {
	spi_rw_byte(0x79|0x80, ch);
}

void broadcast_enable(void) {
	spi_rw_byte(0x32|0x80, 0x88); 
}

void header_enable(void) {
	spi_rw_byte(0x43|0x80, 0xFF);			//header enable
}

void header_disable(void) {
	spi_rw_byte(0x43|0x80, 0x00);			//header disable
}

void set_header(uint8_t header) {
	spi_rw_byte(0x3a|0x80, header);		//transmit header
	spi_rw_byte(0x3f|0x80, header);		//check header
}

uint8_t get_header(void) {
	return spi_rw_byte(0x47,0x00);
}

static uint8_t *rf_isr_buf, rf_tx_cnt;

void si4432_tx(uint8_t *buf, uint8_t len)
{
uint8_t i;
	
    spi_rw_byte(0x0e|0x80, 0x01);              	//设置天线开关的方向

    spi_rw_byte(0x08|0x80, 0x03);               
    spi_rw_byte(0x08|0x80, 0x00);               // 清发射，接收缓冲区
	
    spi_rw_byte(0x03,0x00);		       						// 清RF模块中断
//    spi_rw_byte(0x04,0x00);

    spi_rw_byte(0x05|0x80, 0x04);	       				// 整包数据发射完后，产生中断
//    spi_rw_byte(0x06|0x80, 0x00);	

    spi_rw_byte(0x3E|0x80, len);
//    spi_rw_bytes(0x7f|0x80, buf, len);         // 将要发射的数据载入缓冲区
	
		if(len <=  64) {
			for(i=0; i<len; i++) {
				spi_rw_byte(0x7F|0x80, *buf++);
			}
		} else {
			spi_rw_byte(0x05|0x80, 0x24);			
			
			for(i=0; i<64; i++) {
				spi_rw_byte(0x7F|0x80, *buf++);
				len--; 
				rf_tx_cnt = len;
				rf_isr_buf = buf;
			}			
		}
//    spi_rw_byte(0x08|0x80, 0x00);

	spi_rw_byte(0x07|0x80, 0x08);               // 进入发射模式
}

void txfae_isr(void) {
uint8_t i;
	
	if(rf_tx_cnt > 0) {
		if(rf_tx_cnt > 0x20) {
			for(i=0; i<0x20; i++) {
				spi_rw_byte(0x7F|0x80, *rf_isr_buf++);
				rf_tx_cnt--;
			}
		} else {
			for(i=0; i<rf_tx_cnt; i++) {
				spi_rw_byte(0x7F|0x80, *rf_isr_buf++);
			}			
		}
	}
}

void si4432_rx(void)
{
    spi_rw_byte(0x0e|0x80, 0x02);       // 设置天线开关

    spi_rw_byte(0x08|0x80, 0x03);       //清发射，接收缓冲区
    spi_rw_byte(0x08|0x80, 0x08);       //清发射，接收缓冲区

    spi_rw_byte(0x03,0x00);		       //清掉现有的中断标志
    spi_rw_byte(0x04,0x00);		       //清掉现有的中断标志

    spi_rw_byte(0x05|0x80, 0x12);              // RF模块收到整包数据后，产生中断
    spi_rw_byte(0x06|0x80, 0x80);              //

    spi_rw_byte(0x07|0x80, 0x04);              // RF 模块进入接收模式
//    spi_rw_byte(0x08|0x80, 0x00);
}

uint8_t si4432_rcv(uint8_t *buf) {
uint8_t i,cnt;
	cnt = spi_rw_byte(0x4b,0x00);
	for(i=0; i<cnt; i++) {
		*buf++ = spi_rw_byte(0x7f,0x00);
	}
	
	return cnt;
}

void rxfaf_isr(void) {
	
}

